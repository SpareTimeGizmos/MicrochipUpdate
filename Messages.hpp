//++
// Messages.hpp -> message and error handling functions
//
//   COPYRIGHT (C) 2015-2022 BY SPARE TIME GIZMOS.  ALL RIGHTS RESERVED.
//
// LICENSE:
//    This file is part of the NGRR Microchip Data project.  This program is
// free software; you may redistribute it and/or modify it under the terms of
// the GNU General Public License as published by the Free Software Foundation,
// either version 3 of the License, or (at your option) any later version.
//
//    This program is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
// or FITNESS FOR A PARTICULAR PURPOSE.See the GNU General Public License for
// more details.  You should have received a copy of the GNU General Public
// License along with this program. If not, see https://www.gnu.org/licenses/. 
//
// DESCRIPTION:
//   This header file contains a CBadDogs class, macros and various methods
// all for the reporting of errors.  There are three kinds of errors or
// messages possible -
//
//    * MESSAGES are informational and non-fatal.  They are printed on the
//      console via stderr by the MSGS() or MSGF() macros ...
//
//    * ERRORS are fatal and program execution, or at very least the current
//      operation, cannot continue.  They are thown as runtime_exception objects
//      by the ERRS() or ERRF() macros ...
//
//    * DOG RRORS (so called "bad dogs"!) are errors in one dog's or microchip
//      data.  That record cannot be processed, but the remaining dogs/chips
//      can.  Bad dogs are written to stderr AND to a special log file in CSV
//      format.  These are generated by the BADDOGS() or BADDOGF() macros ...
//
//                                      Bob Armstrong [5-Jul-2019]
//
// REVISION HISTORY:
//  5-JUL-19  RLA   New file.
//--
//000000001111111111222222222233333333334444444444555555555566666666667777777777
//234567890123456789012345678901234567890123456789012345678901234567890123456789
#include <string>               // C++ std::string class, et al ...
#include <iostream>             // C++ style output for LOGS() ...
#include <sstream>              // C++ std::stringstream, et al ...
#include "CSVRow.hpp"           // we need the CSVRow ...
#include "CSVFile.hpp"          //  ... and CSVFile classes here
using std::string;              // ...
using std::ostream;             // ...
using std::ostringstream;       // ...
class CDog;                     // ...

// Write simple messages to stderr ...
#define MSGS(args)  std::cout << args << std::endl
#define MSGF(fmt, ...)  fprintf(stderr, fmt, ##__VA_ARGS__)

// Add a dog related error message to the CBadDogs collection ...
#define BADDOGS(pDog, args) {ostringstream os;  os << args;  CBadDogs::AddErrorS(pDog, os.str());}
#define BADDOGF(pDog, fmt, ...)   BADDOGS(CBadDogs::Print(fmt, ##__VA_ARGS__))

//   These macros are used for fatal errors - they format an error string and
// then throw a std::runtime_error exception...
#define ERRS(args) {ostringstream os;  os << args;  throw std::runtime_error(os.str());}
//   Note that the "##" in front of __VA_ARGS__ is a gcc hack to remove the
// trailing comma when the variable argument list is empty. Amazingly, Visual
// C++ seems to understand it too (or at least it doesn't complain!!).
#define ERRF(fmt, ...) ERRS(CBadDogs::Print(fmt, ##__VA_ARGS__));


class CBadDogs : public CCSVFile {
  //++
  //   The CBadDogs class is a collection of dog related error messages.  These
  // are collected and saved as a CSV file - since this list of errors is usually
  // emailed to the A/Cs it's convenient to have it listed in a spreadsheet,
  // and we already have methods for creating CSV files handy.  Each CSV record
  // contains a dog name, NGRR number, primary contact name, and the text of an
  // error message.
  //
  //   Note that although this class is a collection, we don't actually need
  // any collection related definitions here.  The CCSVFile class we contain
  // is more than enough ...
  //
  //   Moreover, notice that CBadDogs is a singleton class.  There is exactly
  // one instance of this object in the entire program, and it's used to log
  // all bad dog errors.  This single instance is created by a call to the
  // constructor; a pointer to that instance is saved in the static data, and
  // instance is deleted by the destructor.  A call to the member AddError()
  // method implicitly uses this instance.
  //--

  // Column numbers for the bad dog report ...
public:
  enum {
    COL_DOG_NAME			=  1,	// dog name
    COL_DOG_NUMBER			=  2,	// NGRR dog number (guaranteed to be unique!)
    COL_CONTACT_MEMBER		        =  3,	// NGRR member (A/C?) to contact about this dog
    COL_MESSAGE				=  4,	// error message
    TOTAL_COLUMNS 			=  4	// number of colums in a bad dog CSV
  };
  // This is the expected header row for the dog information report ...
  static const string m_sColumnHeaders;         // Header row for CSV file

public:
  // Constructor and destructor ...
  CBadDogs (const string sFileName);
  virtual ~CBadDogs();
  // Copy and assignment constructors ...
  CBadDogs (const CBadDogs &dogs) = delete;
  CBadDogs& operator= (const CBadDogs &dogs) = delete;
  // Destructor ...

  // CBadDogs collection properties ...
public:
  // Return a pointer to the one and only CBadDogs collection ...
  static CBadDogs *Get() {assert(m_pBadDogs != NULL);  return m_pBadDogs;}

  // CBadDogs public methods ...
public:
  // Convert a printf() style argument list to a string ...
  static string Print (const char *pszFormat, ...);
  // Add an error message to this collection ...
  void AddError (const CDog *pDog, const string sMsg);
  static void AddErrorS (const CDog *pDog, const string sMsg) {Get()->AddError(pDog, sMsg);}
  // Write the error messages to a CSV file ...
  void WriteFile (const string &sFileName="") const;

  // Local CBadDogs members ...
protected:
  // Note that these members are all STATIC!
  static CBadDogs *m_pBadDogs;  // the one and only instance of this collection
  static string    m_sFileName; // CSV file to save the errors 
};

